# Modifying data
In environments supporting data manipulation, QL can also be used to creating, modify, and delete data. Fortunately, the syntax for performing these operations begins with the [queries described already](./queries.md).

## Create
Values can be added to a collection using the `into` keyword:
```
from [1, 2, 3, 4] as v
select v into values;
```

The `into` keyword specifies the target for a query, namely `values` here. The target must be compatible with the values generated by the query. On a particular platform, `values` could be an in-memory collection, a file, or a remote database table - that's an implementation detail.

Not all creation operations require inspecting another collection. Inserting a single value can be achieved like this:
```
select { firstName: "Bob", lastName: "Smith" } into values;
```

## Update
Values can be updated in-place using the `update` operation:
```
from values as v
where values % 2 == 0
update v (v + 1); # produces [1, 3, 3, 5]
```

The `update` keyword is followed by the value being updated, namely `v` here. After that is the new value. This gets more interesting when working with a complex type:
```
from customer as c
where c.id == 123
update c { ...c, firstName: "Bob" };
```

Here, we are saying replace the first name of the customer whose `id == 123` with `"Bob"`.

## Delete
Values can also be removed in-place, using the `delete` operation:
```
from values as v
where value % 2 == 0
delete v; # produces [1, 3]
```

## Merge (Experimental)
Creation, modification, and deletion can be combined into a single operation:
```
from customers as c
let total = 
    from c.orders as o
    aggregate sum(o.totalAmount)
let isIncluded = total > 1000
merge sales_totals as st on st.customerId == c.id
when c == null && isIncluded then
    select { customerId: c.id, sales: total } into st
when c != null && isIncluded then
    update st { ...st, sales: total }
when c != null && !isIncluded then
    delete st;
```